## コーディングとAIの時代遷移

IDEの保管機能

↓

AIのインライン保管、提案

↓

AIAgentが自律的に探索、実装、テスト

人間の介入が少なくなっていく


## コーディングエージェントの基本動作

アプリケーションがオーケストレーターとして振る舞う
- 例：QDeveloperがLLMを呼び出し、推論させ、タスクを完遂させる

ツールが環境へアクセスしに行く
- LLM自体には外部と連携する術はない
- 例：MCPによって外部ツールと連携




## AI駆動開発

AIを中心に考える
- AIによるタスク解決を開発プロセスに組み込む

人間中心の開発手法との乖離
- どうすればAIを自律的に働かせられるか？
- どうすればPJ固有の課題を解決させられるのか？



## AIが意図した通りに動かない？

LLMの特徴
- 確率的に次のトークンを推論する
- 与えられた文脈に対して最も確率的に適してそうな回答を返す


雑なプロンプトを投げると次の回答が推測できない
- 「ToDoアプリを作って」→どんなアプリケーションが作られるか予想できない
- 上手く動いているコードを壊さないように変更を積み重ねていく


AIに期待する振る舞いを言語化する
- 隔離的な選択のリスクを減らし、エンジニアの意図を伝える
- AI駆動開発のスキルを身に着け、AIを操作、制御する必要がある



## AI駆動開発のスキル・価値が他の人に伝わりづらい

AI駆動開発の特徴
- これまでの開発基盤が強固なほど実践できる
  - 開発プラクティスの習熟度 + 言語化 + 生成AIへの理解
- 同一事象に対して、人によって異なるアプローチを取る
- 外から眺めていても把握できず、繰り返しやってみる必要がある

つまり、
- 人によってスキル、バックグラウンドが違う
- その違いによってやり方が人それぞれ
- 結果、見ているだけでは分からない



## Everything as Codeというプラクティス

人とAIのコンテクストの差を「コード」で埋めるという手法
- あらゆるものをコードで管理する
- 変更を追跡できるようにすることで、再現性と一貫性を担保する

つまり、人間しか知らないことをなくす
- インフラ、ドキュメント、オペレーション、データベースなど、、、
- 口頭での会話、手動での設定変更、暗黙的なルール・文化
- Gitリポジトリをみればすべて分かる状態を目指す


OSSが参考になる
- 大人数、非同期なコミュニケーションが多いため
- Github上ですべての会話を行う、意思決定プロセスを残す
- 開発のライフサイクルもドキュメントとして管理
- →APIでAIが参照でき、要約・学習させることができる





## AI駆動開発を組織の能力にするには

ビジネス価値
- ユーザーの課題解決の対価
- 顧客体験は計画的に作れない
- FBをもとに継続的に改善していく必要がある

AI駆動開発への期待
- チームが素早くデリバリーできる能力を獲得
- ユーザーにより多くの価値を提供できる

> [!IMPORTANT]
> 生産性向上はAI駆動開発の目的ではない
>
> ユーザーへの価値提供をより多くすることが真の目的であって、生産性向上はその手段
>
> 「素早く、正しいものを作る」チームを目指す
>
> 例：「AI駆動開発で生産性は何倍になりますか？」「人的リソースをどれだけ減らせますか？」を目的としていない


AI駆動に対する個人の受け止め方はさまざま
- 完全にAIにお任せしている人、AIの品質に納得していない人、、、
- 使用する技術、ビジネスドメイン、個人の信条などが影響


AI駆動開発は武道の型に似ている
- 言葉の説明では価値が伝わりづらい
- 時間をかけてマスターして初めて価値に気づく（アジャイル開発もそう）
- 型を主体（人）へ内在化させ、それぞれのアレンジを許容する


AI駆動開発の型はまだ定まっていない
- 基本の型をもとに、自分自身のAI駆動開発の型を編み出す
- Everything as Codeも型の1つ


ただし、他人に強制することは難しいため、個人が取り組める場をまずは作ること
- 使ってみる→型を主体それぞれへ内在化させる→アレンジを通して発露する
- 型はよりよいプラクティスへ柔軟に変化させて文化とする




## 実践的なTips

できるだけ具体的なもの示してプロンプトする
- すでにあるデータのCSVを読み込んでDBスキーマを生成させる
- ステップバイステップで人のレビューを通しつつ、少しづつプロンプトを入れて作っていく


設計
- 要件を伝えて技術選定をサポートしてもらう
- やりたいことを示しつつ、適しているアーキテクトを考えさせる
- 必ずアーキテクチャ設計を文書化させる

複雑な場合、ドキュメントから作成することを推奨
- 要件を伝えてドキュメントを作らせる→あとでコーディングで使う
- プレーンテキスト（MD）であると、少ないトークン数で利用できるしGitもできる

ドキュメントを対象者ごとに作る
- 人間が使う、人間とコントリビューターが使う、AIだけが参照する
- Readme, docs/
  - エンドユーザー向け
  - これは何なのか、どうやって使うのか
- design/, contributing/
  - 開発者、AI向け
  - 内部的な設計・指針
- instructions/
  - AI向け
  - AIへの指示、局所的な知識など

OSSのリポジトリはこのパターンが多いので参照したほうがいい
- 特にビルド、テストの実行方法をcontributing/に置く
- 開発者が遵守すべきビルド、デプロイなどルールを決める
- AIに効率的に作業してもらうため



